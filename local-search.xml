<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2023年度总结与反思</title>
    <link href="/2023/12/28/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2023/12/28/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>今年的关键词是——<strong>迷茫</strong>，状态介于劳资服了和劳资不服之间，我由一个理想主义者开始慢慢转变成了一只犬儒，时常遁入虚无，内耗很多也说了很多屁话，矫情又脆弱，令人痛苦的模式一直在困扰着我，即便知道理解这种狗屎反馈却又难以摆脱。</p></blockquote><blockquote><p>年初设定个的目标完成度大概在60%左右，阅读量30+（目标50+），新去城市6+（目标6），身体状况↓，体重↑。公司降本增效带来的副作用就是劳资今年忙得不要不要的，年终和领导谈话的时候，聊得是成就感，忙倒也无所谓，主要是没有任何工作成就感。</p></blockquote><blockquote><p>今年继续和不少老友见面聊天，年纪越大聊得话题可能越来越沉重，有人说“经济基础，决定上层建筑”，有人说“他们只是喜欢赚钱而已”，有人说“平凡的人有平凡的活法”，“其实这只是个游戏，但我就是想赢”，人各有各的困局，有些来自各种社会叙事，也有些来自自身的拧巴。比如，我就是个泥泞的人。</p></blockquote><blockquote><p>大概是特殊的成长经历，造就了我的低物欲，钱很重要但不会是第一位，长久以来活是个“自由人”，也让我能乐观轻快。年近三十，依然自认理想主义知识分子，倾向于自我实现，自觉有点幼稚，但考虑现实实在让人乐观不起来，我这个乡下人啊啊啊啊。</p></blockquote><blockquote><p>我是精英教育的受益人，从小到大就是习惯了名列前茅，各种获奖荣誉加身，在我远古的叙事里，只有赢一直赢才能让我快乐，因为得第一名的感觉真踏马的棒。直到我遇到我清北的同事，直到面对面和他们沟通成为日常，“第一名”的个人叙事在我的脖子上长了个结巴，努力有作用，但成就感突然变得很低。</p></blockquote><blockquote><p>我是A股的输家，一开始也是股市让我错误的认为努力不值一个涨跌，即便我把它当杠杆数字游戏，拥有长线思维，但或多或少经济下行，对经济周期的不确定性，再不断的使我调入情绪陷阱。所以才会花大精力去阅读各种政经书，我想充分的了解每个时代社会结构的顶层设计者如何看待这些问题。输钱的体验超级烂，我得继续改善投资结构！</p></blockquote><blockquote><p>作为一个历史愤青玩家，还是会偶尔抱怨偶尔愤怒，但终于不再花大精力沉溺于各种国事，而改为喜闻乐见，茶余饭后的笑谈。在任何时代，都会有不合理的制度和不合理的分配结构，中国有顶级的知识分子，他们可能伪善但也聪明，在如此臃腐的社会结构老年人叙事里解决这些问题的政经周期都是5到10年起步，这不是我短暂的生命所能承载的内耗量，但依然对人类的苦难抱有深刻的同情。</p></blockquote><blockquote><p>拥抱不确定性。当一个人找不到答案时，往往是因为今日是昨日生活的重复，在不变的生活模式里只会找到确定的答案，长期稳定是好事但也是面对黑天鹅时最大的风险，然鹅生活处处都有操蛋的黑天鹅。所以呢，必须引入巨大变量人才能改变自身的模式，例如换个领导，换个城市，换几个男朋友，响应国家号召产个三胎。</p></blockquote><blockquote><p>还要理解人性。即使最好的亲友，也很有可能背叛欺骗离开我，不是因为他们不够善良，恰恰因为他们只是普通的一个人，我也一样。每个人都困于自身的躯壳，眼睛所看到的身体所体会的形成了他对世界的基本认知，基因的自私性表象又各有不同。举个例子，我的父母的观念里是养儿防老，我很理解命运带给他们的太多苦难塑造了这种不安，我想给他们安全感。</p></blockquote><blockquote><p>爸妈也需要成就感。很显然，现在已经不是他们的时代，自身没有话语权也没人为他们发声。我完成了我给爸妈吹下的所有牛逼，我也理解乡土对他们的塑造，这时常造成了我们的沟通困扰，我需要耐心和更多的沟通技巧，这些都不应该困住我但时常还是让我感到焦虑。</p></blockquote><blockquote><p>今年，我继续和很多老者，陌生人沟通过，我在以我的方式观察人间。我慢慢不再试图跨越偏见，各种世俗隔阂，我听过很多种不同的表达，我听到过疲劳和振奋，也听到过深省，但很少，实在很少有人让我看到旺盛的生命力，那种审美的扩张，丰富的层次。<br>几千年的文明，诞生了无数的故事，总有一些美好值得相信，我还是希望鼓舞朋友们继续相信，对抗虚无对抗脆弱对抗那些莫名其妙的<img src="/img.png" alt="img.png">东西，因为马思克曾经说过一堆原子自旋还踏马符合客观规律，生命简直太美了。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>个人生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年度总结与反思</title>
    <link href="/2022/12/28/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2022/12/28/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote></blockquote><blockquote><p>即便如此，今年依旧去了五六七八个新的城市，加强了与老朋友的链接，面对面聊天的感觉很棒。买书20本左右，读书也在20本左右，阅读量有所回升但也远远不够，经济类书籍渐渐占据主流，这是我以前批判为很功利的学科。很遗憾没能遇到合适的电影激起消费的冲动，但年底拾起了科幻类的电影那片新天地，这是我以前能看瞌睡的品类。</p></blockquote><blockquote><p>关于美的新鲜感，《美的历程》《谈美》给了我挺好的审美指导，能更好观测实物，体验的层次感又增多了一番。另外报了摄影提高班，对构图及色彩有了些新的认识，被动增加了图片+视频后期的学习，实践成果一般，但也算个好的开始。未来随着疫情放开将要去到更多不同城市，国家，感受不同风土人情的新鲜感。</p></blockquote><hr><blockquote><p>要做的更多的，是认识论的更新，想用认识论去指导行动。因为长期的程序式理性思维，一方面对现实不信任，另一方面容忍不了失序，导致了人越来越焦虑失控，例如我的键盘都是降噪的，问题越积越多，继续逃避绝对是最差的策略之一，所以反思。</p></blockquote><blockquote><p>理性的第一杀手是情绪化。往死了讲，没法管理好情绪的人，没法控制人生。一般来说，我算是情绪稳定的小伙，但今年依旧因为情绪化说了很多傻话，表现出了更多无力感，回头看本是可以克服的，但倒在第一步，玻璃心还是需要多用烈火炼。</p></blockquote><blockquote><p>难得是言行一致，也是始终表里如一。人品（善良正直勇敢）是现实世界中稳定的锚，诚实是最好的沟通技巧，其次嘴巴只是个媒介，最重要的还是做了什么，做不到就不要说，说过的话我都记着，要去兑现。</p></blockquote><blockquote><p>即便是过分的自信也远远好于自卑，但傲慢只会让我忘本，靠运气得到的会靠实力失去。今年在我以为的价值投资最高点几乎实现了本金翻倍，但后面因为投机全亏了回去。另外常常自以为是的给人传输价值观的我该收手了，我什么都不懂。</p></blockquote><blockquote><p>我认识论基本构成依然是无知。说得越多越能证明自己的无知，今年我在经济政治上抱怨了不少。甚至想着逆周期，我怎么可能跑出周期？事实证明我对经济政治学一无所知，在年底补了几十万字的理论知识，我对家国的认同感越来越强，同时也发现学习门槛很高，我才走到门口，还需要多花点时间。</p></blockquote><blockquote><p>选择比努力重要。以前我会喜欢站“努力”，因为觉得要做的“选择”其实很少。事实上，选择很多，我只是喜欢简单，放弃了选择。学习经济学，博弈论，心理学，特别是微观经济学很有必要，以前只是知道交易成本和边际成本等等概念，决策主要靠经验，以后要多加优化决策模型。时间很值钱，我的时间会越来越值钱。对于大多数个体来讲，知识是第一生产力。</p></blockquote><blockquote><p>罗马不是一夜建成的，坏习惯每多持久一点，劣势就多增一分，社会学意义上的成功是优势积累的过程。下半年，我在饮食结构，作息习惯，消费结构(房租成本)等等方面有做出改进，程度在40%，离及格都有距离，需要时间。拿减肥成功来说，由任务式的观念转变为挑战式容易让我获得成就感，不会强压自己但食物下口之前会看卡路里，培养一些有序的小的有序的好习惯有利于养成长期自律。</p></blockquote><blockquote><p>财富健康和自由是大多数人的毕生追求，没有稳定的物质基础，很难有体面的自由。从小到大，连下五子棋我都宁愿输也不愿意多思考一步，我希望跳脱游戏规则。但是现在的我喜欢这些挑战，因为我想赢下这把游戏。</p></blockquote><blockquote><p>充分运用逆向思维，帮助我逃离了不少悲观陷阱，但不代表我不承认现实的困难，我想转变的是面对困难时的态度。喜剧艺术是要高于生活的，这是我吃过米饭后，所能给出的答案。即时满足谁都想要，这是人性的自然反应，但难的是保持长期的高效和收益。对于未来，要有自信，坚持长期主义，理性且乐观。我的同事们就常说我总是太乐观了，但我深知解决问题才是我的工作，知识与经验的积累让我拥有应付各种问题的底气。</p></blockquote><blockquote><p>长篇大论不代表什么，这么多套话也不显诚意，因为没有实证。这是个十分需要耐心和勇气的年纪，未来也会更加困难，但相信每个人都会找到自己的节奏，来实现自己的小的大的梦想。我喜欢挑战，相信光，继续无限看好自己！</p></blockquote><blockquote><p>略略略略略略</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>个人生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVCC</title>
    <link href="/2022/12/09/MVCC/"/>
    <url>/2022/12/09/MVCC/</url>
    
    <content type="html"><![CDATA[<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><pre><code class="hljs">多版本控制（Multiversion Concurrency Control）: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，InnoDB通过undo log保存每条数据的多个版本，并且能够找回数据历史版本提供给用户读，每个事务读到的数据版本可能是不一样的。在同一个事务中，用户只能看到该事务创建快照之前已经提交的修改和该事务本身做的修改。MVCC在 Read Committed 和 Repeatable Read两个隔离级别下工作。MySQL的InnoDB存储引擎默认事务隔离级别是RR(可重复读)，是通过 &quot;行级锁+MVCC&quot;一起实现的，正常读的时候不加锁，写的时候加锁。而 MVCC 的实现依赖：隐藏字段、Read View、Undo log。</code></pre><h2 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h2><pre><code class="hljs">+ DB_TRX_ID(6字节)：表示最近一次对本记录行作修改（insert | update）的事务ID。至于delete操作，InnoDB认为是一个update操作，不过会更新一个另外的删除位，将行表示为deleted。并非真正删除。+ DB_ROLL_PTR(7字节)：回滚指针，指向当前记录行的undo log信息+ DB_ROW_ID(6字节)：随着新行插入而单调递增的行ID。理解：当表没有主键或唯一非空索引时，innodb就会使用这个行ID自动产生聚簇索引。如果表有主键或唯一非空索引，聚簇索引就不会包含这个行ID了。这个DB_ROW_ID跟MVCC关系不大。</code></pre><h2 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h2><p>  Read View(读视图)主要是用来做可见性判断的, 里面保存了“对本事务不可见的其他活跃事务”。<br>  <a href="https://github.com/facebook/mysql-5.6/blob/42a5444d52f264682c7805bf8117dd884095c476/storage/innobase/include/read0read.h#L125">源码</a><br>  如下：</p><p>  <img src="https://outman-1252077993.cos.ap-nanjing.myqcloud.com/20200404112320346.png"></p><ul><li>low_limit_id：目前出现过的最大的事务ID+1，即下一个将被分配的事务ID</li><li>up_limit_id：活跃事务列表trx_ids中最小的事务ID，如果trx_ids为空，则up_limit_id 为 low_limit_id</li><li>trx_ids：Read View创建时其他未提交的活跃事务ID列表。意思就是创建Read View时，将当前未提交事务ID记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的</li><li>creator_trx_id：当前创建事务的ID，是一个递增的编号</li></ul><h2 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h2><p>  Undo log中存储的是老版本数据，当一个事务需要读取记录行时，如果当前记录行不可见，可以顺着undo log链找到满足其可见性条件的记录行版本。<br>  大多数对数据的变更操作包括 insert&#x2F;update&#x2F;delete，在InnoDB里，undo log分为如下两类：</p><ul><li><p>insert undo log : 事务对insert新记录时产生的undo log, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。</p></li><li><p>update undo log : 事务对记录进行delete和update操作时产生的undo log，不仅在事务回滚时需要，快照读也需要，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。 </p><pre><code class="hljs">Purge线程：为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下旧记录的deleted_bit，并不真正将旧记录删除。为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。purge线程自己也维护了一个read view，如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</code></pre></li></ul><h2 id="记录行修改的具体流程"><a href="#记录行修改的具体流程" class="headerlink" title="记录行修改的具体流程"></a>记录行修改的具体流程</h2><p>假设有一条记录行如下，字段有Name和Honor，值分别为”curry”和”mvp”，最新修改这条记录的事务ID为1。<br>  <img src="https://outman-1252077993.cos.ap-nanjing.myqcloud.com/20200701205716343.png"></p><ul><li><p>现在事务A（事务ID为2）对该记录的Honor做出了修改，将Honor改为”fmvp”：<br>  <img src="https://outman-1252077993.cos.ap-nanjing.myqcloud.com/20200701210046670.png"></p><ul><li>事务A先对该行加排它锁</li><li>然后把该行数据拷贝到undo log中，作为旧版本</li><li>拷贝完毕后，修改该行的Honor为”fmvp”，并且修改DB_TRX_ID为2（事务A的ID）, 回滚指针指向拷贝到undo log的旧版本。（然后还会将修改后的最新数据写入redo log）</li><li>事务提交，释放排他锁</li></ul></li><li><p>接着事务B（事务ID为3）修改同一个记录行，将Name修改为”iguodala”：</p><ul><li>事务B先对该行加排它锁</li><li>然后把该行数据拷贝到undo log中，作为旧版本</li><li>拷贝完毕后，修改该行Name为”iguodala”，并且修改DB_TRX_ID为3（事务B的ID）, 回滚指针指向拷贝到undo log最新的旧版本。</li><li>事务提交，释放排他锁</li></ul></li></ul><p>  <img src="https://outman-1252077993.cos.ap-nanjing.myqcloud.com/2020070121022442.png">  </p><pre><code class="hljs">从上面可以看出，不同事务或者相同事务的对同一记录行的修改，会使该记录行的undo log成为一条链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录。</code></pre><h2 id="可见性比较算法"><a href="#可见性比较算法" class="headerlink" title="可见性比较算法"></a>可见性比较算法</h2><p>  在innodb中，创建一个新事务后，执行第一个select语句的时候，innodb会创建一个快照（read view），快照中会保存系统当前不应该被本事务看到的其他活跃事务id列表（即trx_ids）。当用户在这个事务中要读取某个记录行的时候，innodb会将该记录行的DB_TRX_ID与该Read View中的一些变量进行比较，判断是否满足可见性条件。</p><p>  假设当前事务要读取某一个记录行，该记录行的DB_TRX_ID（即最新修改该行的事务ID）为trx_id，Read View的活跃事务列表trx_ids中最早的事务ID为up_limit_id，将在生成这个Read Vew时系统出现过的最大的事务ID+1记为low_limit_id（即还未分配的事务ID）。</p><p>  具体的比较算法如下（可以照着后面的 例子 ，看这段）:</p><ul><li>如果 trx_id &lt; up_limit_id, 那么表明“最新修改该行的事务”在“当前事务”创建快照之前就提交了，所以该记录行的值对当前事务是可见的。跳到步骤5。</li><li>如果 trx_id &gt;&#x3D; low_limit_id, 那么表明“最新修改该行的事务”在“当前事务”创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤4。</li><li>如果 up_limit_id &lt;&#x3D; trx_id &lt; low_limit_id, 表明“最新修改该行的事务”在“当前事务”创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表trx_ids进行查找（源码中是用的二分查找，因为是有序的）：<ul><li>(1) 如果在活跃事务列表trx_ids中能找到 id 为 trx_id 的事务，表明①在“当前事务”创建快照前，“该记录行的值”被“id为trx_id的事务”修改了，但没有提交；或者②在“当前事务”创建快照后，“该记录行的值”被“id为trx_id的事务”修改了（不管有无提交）；这些情况下，这个记录行的值对当前事务都是不可见的，跳到步骤4；</li><li>(2)在活跃事务列表中找不到，则表明“id为trx_id的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见，跳到步骤5。</li></ul></li><li>在该记录行的 DB_ROLL_PTR 指针所指向的undo log回滚段中，取出最新的的旧事务号DB_TRX_ID, 将它赋给trx_id，然后跳到步骤1重新开始判断。</li><li>将该可见行的值返回。</li></ul><h2 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h2><p>  **快照读(snapshot read)**：普通的 select 语句(不包括 select … lock in share mode, select … for update)</p><p>  <strong>当前读(current read)</strong> ：select … lock in share mode，select … for update，insert，update，delete 语句（这些语句获取的是数据库中的最新数据，官方文档：14.7.2.4 Locking Reads ）</p><p>  只靠 MVCC 实现RR隔离级别，可以保证可重复读，还能防止部分幻读，但并不是完全防止。</p><p>  比如事务A开始后，执行普通select语句，创建了快照；之后事务B执行insert语句；然后事务A再执行普通select语句，得到的还是之前B没有insert过的数据，因为这时候A读的数据是符合快照可见性条件的数据。这就防止了部分幻读，此时事务A是快照读。</p><p>  但是，如果事务A执行的不是普通select语句，而是select … for update等语句，这时候，事务A是当前读，每次语句执行的时候都是获取的最新数据。也就是说，在只有MVCC时，A先执行 select … where nid between 1 and 10 … for update；然后事务B再执行  insert … nid &#x3D; 5 …；然后 A 再执行 select … where nid between 1 and 10 … for update，就会发现，多了一条B insert进去的记录。这就产生幻读了，所以单独靠MVCC并不能完全防止幻读。</p><p>  因此，InnoDB在实现RR隔离级别时，不仅使用了MVCC，还会对“当前读语句”读取的记录行加记录锁（record lock）和间隙锁（gap lock），禁止其他事务在间隙间插入记录行，来防止幻读。也就是前文说的”行级锁+MVCC”。</p><h2 id="RR和RC的Read-View产生区别："><a href="#RR和RC的Read-View产生区别：" class="headerlink" title="RR和RC的Read View产生区别："></a>RR和RC的Read View产生区别：</h2><p>  ①在innodb中的<strong>Repeatable Read</strong>级别, 只有事务在begin之后，执行第一条select（读操作）时, 才会创建一个快照(read view)，将当前系统中活跃的其他事务记录起来；并且事务之后都是使用的这个快照，不会重新创建，直到事务结束。</p><p>  ②在innodb中的<strong>Read Committed</strong>级别, 事务在begin之后，执行每条select（读操作）语句时，快照会被重置，即会重新创建一个快照(read view)。</p><p>  官方文档：consistent read，里面所说的consistent read 一致性读，我的理解就是 快照读，也就是普通select语句，它们不会对访问的数据加锁。     只有普通select语句才会创建快照，select … lock in share mode，select … for update不会，update、delete、insert语句也不会，因为它们都是 当前读，会对访问的数据加锁。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java性能调优指北</title>
    <link href="/2022/12/09/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%8C%87%E5%8C%97/"/>
    <url>/2022/12/09/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><pre><code class="hljs">无论是复杂的现实世界还是复杂的计算机系统，性能调优始终是一门艺术，它建立在知识与经验之上；java性能调优主要探讨两个点：1 ，如何通过JVM的配置来影响程序的各项性能指标；2 ，理解java平台特性（java语音以及java API）对性能的影响；</code></pre><h2 id="性能调优工具"><a href="#性能调优工具" class="headerlink" title="性能调优工具"></a>性能调优工具</h2><ul><li><p>操作系统工具</p><ul><li>CPU使用率<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vmstat</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>性能调优的目的是尽可能短的时间内让CPU使用率更高</li><li>CPU运行队列（可运行队列长度）<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">c</span>:&gt; typeperf -si <span class="hljs-number">1</span> <span class="hljs-string">&quot;\System\Processor Queue Length&quot;</span><br></code></pre></td></tr></table></figure>如果试图运行的线程数超过可用CPU，系统过载，性能就会下降</li><li>磁盘使用率<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">iostat</span> -xm <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>对于所有应用来说，即便不直接写磁盘，系统交换仍会影响它们的性能<br>写入磁盘的应用遇到瓶颈，要么写入效率不高（吞吐太低），要么写入太多数据（吞吐太高）</li><li>网络使用率<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nicstat</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>千兆位网络理论每秒处理125MB，但网络无法支持100%使用率，对于本地以太局域网来说，<br>承受的网络使用率超过40%就以为着接口饱和了，所以基于网络的应用，要监控网络确保其不成为瓶颈。</li></ul></li><li><p>java 监控工具</p><ul><li><strong>jcmd</strong> 用于打印java进程所涉及的基本类，线程和VM信息</li><li><strong>jconsole</strong> 提供JVM活动的图形化师徒，包括线程和类的使用以及GC活动</li><li><strong>jhat</strong> 读取分析内存堆转储</li><li><strong>jmap</strong> 提供堆转储和其他JVM内存使用的信息</li><li><strong>jinfo</strong> 查看JVM系统属性，可以动态设置一些系统属性</li><li><strong>jstack</strong> 转储栈信息</li><li><strong>jstat</strong> 提供GC和类装载活动的信息</li><li><strong>jvisualvm</strong> 监视JVM的GUI工具</li><li><strong>Arthas</strong> 阿里巴巴开源java诊断工具</li></ul></li></ul><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><pre><code class="hljs"> JIT是just in time 的缩写, 也就是即时编译编译器。使用即时编译器技术，能够加速 Java 程序的执行速度。 对于 Java 代码，刚开始都是被编译器编译成字节码文件，然后字节码文件会被交由 JVM 解释执行，所以可以说 Java 本身是一种半编译半解释执行的语言。 Hot Spot VM 采用了 JIT compile 技术，将运行频率很高的字节码直接编译为机器指令执行以提高性能，所以当字节码被 JIT 编译为机器码的时候，要说它是编译执行的也可以。也就是说，运行时，部分代码可能由 JIT 翻译为目标机器指令（以 method 为翻译单位，还会保存起来，第二次执行就不用翻译了）直接执行。</code></pre><ul><li><p><strong>client</strong>   -server</p><p>client编译器开启编译比server编译器要早，适用于注重启动时间的应用</p></li><li><p><strong>server</strong>  -client</p><p>   适用于长期运行又要求高性能的应用</p></li><li><p>分层编译   -XX:TieredCompilation</p><p>   启动时用client编译器，代码变热后用server编译器</p></li><li><p>调优代码缓存</p><p>   JVM编译代码后会保留编译后的汇编语言指令集，代码缓存的大小固定，如果代码缓存过小，一旦被热点代码占满了空间，会导致其他代码解释执行</p><p>   设置代码缓存最大值：**-XX:ReservedCodeCacheSize&#x3D;N**<br>   设置代码缓存初始值：**-XX:InitialCodeCacheSize&#x3D;N** </p></li><li><p>编译阈值 </p><p>jvm通过方法调用计数器和回边计数器检测方法调用总数，达到阈值是，开启编译</p><p><strong>-XX:CompileThreshold&#x3D;N</strong> 设置代码循环执行多少次转而进行编译，调整这个值可以使编译更早发生</p></li><li><p>检测编译过程<br>-XX:PrintCompilation</p></li><li><p>编译线程</p><p>当方法（或循环）适合编译时，会进入编译队列，调用次数最高的方法拥有最高优先级，编译队列则由一个或多个后台进程处理</p></li></ul><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>   对于java而言垃圾回收主要分为两步</p><pre><code class="hljs">1.找到不再使用的垃圾对象2.释放这些对象所占用的内存（必要时还需要进行整理）</code></pre><p>   分代算法内存模型<br>   <img src="https://outman-1252077993.cos.ap-nanjing.myqcloud.com/heapstruct.png"></p><p>   标记整理(mark-sweep-compact)算法示例<br>   <img src="https://outman-1252077993.cos.ap-nanjing.myqcloud.com/GC_Mark_Compact.jpg"></p><p>   HotSpot虚拟机所包含的常见垃圾回收器,<strong>如果两个收集器之间存在连线，则说明它们可以搭配使用</strong></p><p>   <img src="https://outman-1252077993.cos.ap-nanjing.myqcloud.com/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png"></p><table><thead><tr><th align="left">垃圾回收算法</th><th align="left">简介</th><th align="left">特点</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">Serial 收集器</td><td align="left">Serial收集器是最基本的、发展历史最悠久的收集器</td><td align="left">单线程、简单高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</td><td align="left">适用于Client模式下的虚拟机，100M以下堆</td></tr><tr><td align="left">ParNew收集器</td><td align="left">Serial收集器的多线程版本，除了使用多线程外其余行为均和Serial收集器一模一样</td><td align="left">多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</td><td align="left">ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，因为它是除了Serial收集器外，唯一一个能与CMS收集器配合工作的。</td></tr><tr><td align="left">Parallel Scavenge 收集器</td><td align="left">与吞吐量关系密切，故也称为吞吐量优先收集器。</td><td align="left">属于新生代收集器也是采用复制算法的收集器，又是并行的多线程收集器;GC自适应调节策略（与ParNew收集器最重要的一个区别）</td><td align="left">注重高吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old 收集器</td></tr><tr><td align="left">Serial Old 收集器</td><td align="left">Serial Old是Serial收集器的老年代版本。</td><td align="left">样是单线程收集器，采用标记-整理算法。</td><td align="left">主要也是使用在Client模式下的虚拟机中。也可在Server模式下使用。</td></tr><tr><td align="left">Parallel Old 收集器</td><td align="left">Parallel Scavenge收集器的老年代版本。</td><td align="left">多线程，采用标记-整理算法</td><td align="left">注重高吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old 收集器</td></tr><tr><td align="left">CMS收集器</td><td align="left">一种以获取最短回收停顿时间为目标的收集器。</td><td align="left">基于标记-清除算法实现。并发收集、低停顿。</td><td align="left">适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b&#x2F;s服务。</td></tr><tr><td align="left">G1收集器</td><td align="left">一款面向服务端应用的垃圾收集器</td><td align="left">并行与并发：使用多个CPU来缩短Stop-The-World停顿时间，支持用户线程和回GC线程并发执行。分代收集：G1能够独自管理整个Java堆，并且采用不同的方式去处理不同存活周期的对象；空间整合：G1运作期间不会产生空间碎片，收集后能提供规整的可用内存。可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型。</td><td align="left">CMS适用算法较G1简单，在小堆是性能更佳；而在大堆中，G1性能更佳；CMS不对堆进行压缩整理，碎片率较G1高</td></tr></tbody></table><h3 id="GC调优基础"><a href="#GC调优基础" class="headerlink" title="GC调优基础"></a>GC调优基础</h3><ul><li>调整堆的大小  -Xms -Xmx</li><li>代空间的调整  调整新老年代空间的大小；新生代过大垃圾收集频率低，但相应老年代太小易引发Full Gc</li><li>控制并发    调整GC线程数，__ParallelGCThreads &#x3D; 8+((N-8)*5&#x2F;8)__，如果多个JVM运行在同一台物理机，需要减少该线程数</li><li>自适应调整   默认开启，JVM会根据策略，不断尝试选择最优代空间分配</li></ul><p>###CMS垃圾收集器调优</p><p>   CMS收集器的工作过程图：</p><p>   <img src="https://outman-1252077993.cos.ap-nanjing.myqcloud.com/CMS%E6%94%B6%E9%9B%86%E8%BF%87%E7%A8%8B.png"></p><p>   CMS收集器有三种基本操作</p><ul><li>CMS会对新生代的对象进行回收</li><li>CMS会启动一个并发的线程对老年代进行回收 </li><li>如果有必要，CMS会发起Full Gc<ul><li><strong>并发模式失效</strong>： 新生代发生垃圾回收，同时老年代又没有足够的空间容纳晋升对象时，CMS垃圾回收会退化成FullGc</li><li><strong>晋升失败</strong>： 老年代有足够空间容纳晋升的对象，但由于空闲空间过于碎片化，晋升失败</li><li><strong>解决方案</strong><ul><li>增大堆空间or增大老年代空间  <strong>MaxGCPauseMills&#x3D;N,GCTimeRatio&#x3D;N</strong></li><li>以更高的频率运行后台回收线程  <strong>-XX:CMSInitiatingOccupancyFraction&#x3D;N -XX:+CMSInitiatingOccupancyOnly</strong></li><li>使用更多的后台回收线程   <strong>XX:ConcGCThreads&#x3D;N</strong></li></ul></li></ul></li></ul><h3 id="G1垃圾回收调优"><a href="#G1垃圾回收调优" class="headerlink" title="G1垃圾回收调优"></a>G1垃圾回收调优</h3><p>   G1保留分代思想，但它是针对整个堆并以Region为单位进行垃圾回收，G1的分块大体结果如下图所示：<br>   <img src="https://outman-1252077993.cos.ap-nanjing.myqcloud.com/G1Region.png"></p><p>   G1收集器运行示意图：<br>   <img src="https://outman-1252077993.cos.ap-nanjing.myqcloud.com/G1.png"></p><p>   G1提供了两种GC模式，<strong>Young GC</strong>和<strong>Mixed GC</strong></p><p>   <strong>Young GC</strong>：选定所有年轻代里的Region。通过控制年轻代的Region个数，既年轻代内存大小，来控制Young GC的时间开销。</p><p>   <strong>Mixed GC</strong>：选定所有年轻代里的Region，以及并发标记阶段统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region。</p><p>   G1 只会回收垃圾最多的分区，主要包括以下四种操作</p><ul><li>新生代垃圾回收</li><li>后台收集，并发周期</li><li>混合式垃圾收集</li><li>必要时的Full GC<ul><li><strong>并发模式失效</strong> ：G1垃圾收集启动标记周期，但老年代在周期完成之前已被填满</li><li><strong>晋升失败</strong>： G1收集器完成标记阶段，开启混合式垃圾回收，清理老年代的分区，不过老年代空间在垃圾回收释放出足够内存之前被耗尽</li><li><strong>疏散失败</strong> ： 进行新生代垃圾收集时，Survivor空间和老年代中没有足够的空间容纳所有的幸存对象</li><li><strong>大对象分配失败</strong>： 分配大对象可能导致Full Gc</li><li><strong>解决方案</strong><ul><li><p>增加堆大小或调大老年代</p></li><li><p>增加后台GC线程数 <strong>ConcGCThreads &#x3D; (ParallelGCThreads+2)&#x2F;64</strong></p></li><li><p>以更高的频率进行后台垃圾收集 <strong>-XX:CMSInitiatingHeapOccupancyPercent&#x3D;N</strong> 设置G1在达到N比率时启动收集周期</p></li><li><p>在混合式垃圾回收周期中完成更多的垃圾收集工作</p><ul><li><strong>G1MixedGCLiveThresholdPercent</strong>：老年代中的存活对象的占比，只有在此参数之下，才会被选入CSet（老年代收集集合）。</li><li><strong>G1MixedGCCountTarget</strong>：一次并发标记之后，最多执行Mixed GC的次数。</li><li><strong>G1OldCSetRegionThresholdPercent</strong>：一次混合 GC中能被选入CSet的最多老年代Region数量。</li><li><strong>MaxGCPauseMills</strong> 调节GC停顿最大可忍受时长，调大则每次混合式GC能收集更多老年代分区</li></ul></li></ul></li></ul></li></ul><h3 id="GC高级调优"><a href="#GC高级调优" class="headerlink" title="GC高级调优"></a>GC高级调优</h3><ul><li><p>晋升及Survivor空间</p><ul><li>Survivor空间太小，被占满后，新生代的活跃对象被迫移步老年代<br>如果老年代GC频繁，可以尝试调大堆大小或新生代大小（survivor根据新生代大小按比例算出）</li><li>对象在Survivor中经历的GC周期数有上限，超过则被移动到老年代<br>如果要避免对象过早晋升，可以调大阈值</li></ul></li><li><p>分配大对象       </p><p> ”大型“是一个相对的概念，它取决于Eden空间内TLAB(线程本地分配缓冲区)；<br>  TLAB是线程固有的Eden内存空间，避免了同步操作; 但TLAB过小会导致程序在TLAB之外分配对象，降低性能；因此当需要大量分配大型对象时，调大TLAB大小或新生代大小能提升性能</p></li><li><p>巨型对象<br>  TLAB无法分配的对象，JVM会尝试在Eden中分配，如果仍无法分配，将直接进入老年代；在G1中如果对象超过Region大小，将进入老年代；如若老年代没有合适的连续空间，则可能被迫Full GC，这种情况下需要增大Region的大小</p></li></ul><h2 id="堆内存调优"><a href="#堆内存调优" class="headerlink" title="堆内存调优"></a>堆内存调优</h2><pre><code class="hljs">有节制的创建对象并尽快丢弃，使用更少内存，能显著提升垃圾收集器性能</code></pre><ul><li><p>减少内存使用 </p><ul><li><p>减少对象大小</p><p>减少实例变量个数，<br>能用int 就不用long，能用float就不用double;</p></li><li><p>延迟初始化</p> <figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs smali">public class SafeDoubleCheckedLocking &#123;<span class="hljs-keyword"></span><br><span class="hljs-keyword">private</span> volatile<span class="hljs-keyword"> static</span> Instance instance;<br><span class="hljs-keyword"></span><br><span class="hljs-keyword">public</span><span class="hljs-keyword"> static</span> Instance getInstance() &#123;<br>   <span class="hljs-built_in"> if </span>(instance == null) &#123;<br>        synchronized (SafeDoubleCheckedLocking.class) &#123;<br>           <span class="hljs-built_in"> if </span>(instance == null)<br>               <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>Instance();//instance为volatile<br>        &#125;<br>    &#125;<br>   <span class="hljs-built_in"> return </span>instance;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>尽早清理<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> E remove(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) &#123;<br>    range<span class="hljs-keyword">Check</span>(<span class="hljs-keyword">index</span>);<br><br>    modCount++;<br>    E oldValue = elementData(<span class="hljs-keyword">index</span>);<br><br>    <span class="hljs-type">int</span> numMoved = size - <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">System</span>.arraycopy(elementData, <span class="hljs-keyword">index</span>+<span class="hljs-number">1</span>, elementData, <span class="hljs-keyword">index</span>,<br>    numMoved);<br>    elementData[<span class="hljs-comment">--size] = null; // 清理 让GC完成其工作</span><br><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>字符串保留</p><p> 对于同个字符序列，没有必要存在多个字符串表示;</p></li></ul></li><li><p>对象生命周期管理</p><ul><li><p>对象重用</p><ul><li>对象池（线程池，JDBC池。。。）</li><li>线程局部变量 （ThreadLocal）</li></ul></li></ul></li></ul><h2 id="原生内存调优"><a href="#原生内存调优" class="headerlink" title="原生内存调优"></a>原生内存调优</h2><ul><li><p>大页</p><p>   <img src="https://outman-1252077993.cos.ap-nanjing.myqcloud.com/pagetable.png"></p><p>   视操作系统而言，一般默认开启</p><p>   <strong>页</strong>：页是操作系统内存分配的最小单位，要分配1字节，必须分配1个整页，直至被分配完毕，才会分配一个新页</p><p>   <strong>页表</strong>：存放逻辑页与物理页帧的对应关系。 每一个进程都拥有一个自己的页表</p><p>   <strong>TLB</strong>: 最常用的页表映射保存在TLB中，即页表缓存，但其数目有限；故如果每个页能表示更多内存，则只需要更少的TLB表项就能覆盖 整个程序的内存，查找性能更佳</p></li><li><p>压缩的oop</p><p>   在32位系统中对象引用占<strong>4个字节</strong>，64位系统中占<strong>8个字节</strong>，意味着需要更多的GC周期，因为堆中留给其他数据的空间变少了；</p><p>   JVM可以使用压缩的oop来减少额外的内存损耗  <strong>-XX:-UseCompressedOops</strong></p>   <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Integer</span> i = <span class="hljs-literal">new</span> <span class="hljs-built_in">Integer</span>(<span class="hljs-number">23</span>);<br></code></pre></td></tr></table></figure><p>   <img src="https://outman-1252077993.cos.ap-nanjing.myqcloud.com/oop.png"></p><p>   启用压缩oop后，对象指针变为了4字节</p><ul><li><p>对象指针的实现</p><p>在oop只有32位长是，只可以引用2^32 &#x3D; 4GB;<br>固采用一种折中方案，使用<strong>35位</strong>的oop，2^35&#x3D;32GB,在进入寄存器时左移三位，从寄存器读出时右移三位</p></li></ul></li></ul><h2 id="线程与同步的调优"><a href="#线程与同步的调优" class="headerlink" title="线程与同步的调优"></a>线程与同步的调优</h2><ul><li><p>线程池 </p><p>   线程池大小对获取线程池最佳性能至关重要，过大则带来上下文切换开销，过小增加任务阻塞时长<br>   <img src="https://outman-1252077993.cos.ap-nanjing.myqcloud.com/TreadPool.png"></p><p>   线程池动态化配置方案<br>   <img src="https://outman-1252077993.cos.ap-nanjing.myqcloud.com/dynamicthreadpool.png"></p></li><li><p>线程同步</p><ul><li><p>锁定对象的开销</p><ul><li>重量级锁在多线程竞争情况下，对于每个线程的开销都是一样的，都必须执行加锁操作</li><li>CAS很依赖CPU高速缓存，存在CACHE Miss情况，在多线程竞争时，开销无法预测，最极端的情况下，两个线程都看到对方同时在修改变量值，可能出现死循环。<br> <img src="https://outman-1252077993.cos.ap-nanjing.myqcloud.com/cache_miss.png"></li></ul></li><li><p>避免同步</p><p> 在不存在竞争或少量竞争的情况下，CAS 优于synchronized<br> ；在只读不写的情况下，CAS 优于synchronized；<br> 竞争剧烈的情况下，synchronized表现更好</p></li></ul></li><li><p>伪共享</p>   <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">pulic <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataHolder</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> l1;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> l2;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> l3;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> l4;<br>&#125;<br></code></pre></td></tr></table></figure><p>   基于局部性原理，CPU可能将 l1,l2 加载至同一缓存行，当该缓存行被更新，当前核必须通知其他所有核这个内存被修改了</p></li><li><p>JVM线程调优</p><ul><li><p>调节线程栈大小</p><p>   64位系统线程栈默认大小256kb，在内存比较稀缺的机器上可以减少线程栈大小</p></li><li><p><strong>偏向锁</strong></p><p> java1.6后默认开启，当竞争激烈时偏向锁意义不大，且增大了开销</p></li></ul></li></ul><h2 id="其他调优"><a href="#其他调优" class="headerlink" title="其他调优"></a>其他调优</h2><ul><li><strong>transient</strong>字段，减少需要序列化的数据</li><li>预估设定集合的大小，避免扩容</li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/2022/12/09/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2022/12/09/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><pre><code class="hljs">内存是计算机中一种需要认真管理的重要资源；经过多年的探索，人们提出了分层存储器体系的概念;</code></pre><p><img src="https://hcqpic.oss-cn-shanghai.aliyuncs.com/src%3Dhttp___upload-images.jianshu.io_upload_images_870531-72afe43f349605ab.png%26refer%3Dhttp___upload-images.jianshu.jpg"></p><h2 id="无存储器抽象"><a href="#无存储器抽象" class="headerlink" title="无存储器抽象"></a>无存储器抽象</h2><pre><code class="hljs">最简单的存储器抽象就是根本没有抽象。在早期的大型计算机时代，就没有存储器抽象，每一个程序都直接访问内存，因为要共用内存地址，所以无法同时运行两个程序；</code></pre><h3 id="无存储器抽象下有运行多个程序"><a href="#无存储器抽象下有运行多个程序" class="headerlink" title="无存储器抽象下有运行多个程序"></a>无存储器抽象下有运行多个程序</h3><h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><pre><code class="hljs">即把当前内存中的所有内容保存在磁盘文件，然后把下一个程序读入内存中再运行即可。这样某一个时间内存中只有一个程序，那么就不会发生冲突</code></pre><h4 id="保护键"><a href="#保护键" class="headerlink" title="保护键"></a>保护键</h4><pre><code class="hljs">在IBM360的早期模型中，将内存划分为2Kb的块，每个块被分配一个4位的保护键，保护键存储在CPU的PSW(程序状态字)寄存器中。一个运行种的进程如果访问保护键与其PSW码不同的内存，则会捕获这一事件</code></pre><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><pre><code class="hljs">虽然基于保护键可以使得程序间隔离，但仍无法解决根本问题，它们运行的指令所引用的都是绝对物理地址，仍然在共享物理空间。这个时候需要每个程序都有一段私有的本地地址来进行内存寻址。</code></pre><p><img src="https://hcqpic.oss-cn-shanghai.aliyuncs.com/src%3Dhttp___www.pianshen.com_images_782_ec6e2813d7f1557cf46ce9312eb1e236.png%26refer%3Dhttp___www.pianshen.jpg">   </p><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><pre><code class="hljs">要使多个程序运行在内存中并且相互不影响，需要解决两个问题：保护和重定位。基于此创造一种新的存储器抽象：地址空间就行进程的概念创造了一类抽象的CPU以运行程序一样，地址空间为程序创建了一种抽象的内存。地址空间是一个进程可用于寻址内存的一套地址集合，每个进程都有一个自己的地址空间</code></pre><h3 id="基址寄存器和界限寄存器"><a href="#基址寄存器和界限寄存器" class="headerlink" title="基址寄存器和界限寄存器"></a>基址寄存器和界限寄存器</h3><pre><code class="hljs">每个CPU配置有两个特殊的寄存器，通常叫做基底寄存器和界限寄存器，基底寄存器记录了进程的起始物理地址，程序的长度则装载到界限寄存器。通过基底寄存器，可以换算出程序访问的实际物理地址，通过界限寄存器可以判断程序是否访问超出界限。</code></pre><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><pre><code class="hljs">理论上如果内存足够大，可以保存所有进程。但实际上，内存往往是有限的，而进程却是在不断增加占用内存，甚至超出内存极限。针对内存超载问题，最简单的解决方法是交换，即把一个进程完整的调入内存，使该进程运行一段时间，然后把它存回磁盘。</code></pre><p><img src="https://hcqpic.oss-cn-shanghai.aliyuncs.com/5e146d9cbc2edb31bed70512d4655033.gif"></p><h3 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h3><pre><code class="hljs">在动态分配内存时，操作系统必须对其管理；一般而言有两种方式，一是位图，二是链表</code></pre><h4 id="使用位图管理内存"><a href="#使用位图管理内存" class="headerlink" title="使用位图管理内存"></a>使用位图管理内存</h4><pre><code class="hljs">内存可以分配为小到几个字大到几千字节的分配但愿，01标识是否被占有；主要问题是，在分配内存时，分配K个内存单元，需要搜索位图，找到连续的K个0，这是耗时的操作</code></pre><h4 id="使用链表管理内存"><a href="#使用链表管理内存" class="headerlink" title="使用链表管理内存"></a>使用链表管理内存</h4><pre><code class="hljs">维护一个记录已分配内存段和空闲内存的链表；其中链表中的一个节点或者表示一个进程，或者表示两个进程间的一块空闲区。每个节点都包含以下域：空闲区（H），进程（P）的指示标识，起止地址，长度，和指向下一节点的指针</code></pre><ul><li>首次适配算法   为进程分配内存时，沿着链表搜索，直至找到足够大的空闲区，一部分供进程使用，一部分形成新的空闲区</li><li>下次适配算法   记录上一次分配位置，沿着继续搜索</li><li>最佳适配算法   遍历整个链表，找到与所需内存大小适配最佳空闲区</li><li>最快适配算法   维护一个常用大小的空闲区链表，内存分配时，在此链表上搜索</li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><pre><code class="hljs">基于基底寄存器和界限寄存器的交换技术，给多进程运行提供了便利。但随着多媒体时代的到来，程序对内存的需求日渐旺盛，往运行一个程序便要占用1 2G内存。这对于多进程运行非常不利，同时交互技术还受阻与磁盘的读写能力，因为一个典型的SATA磁盘的峰值传输速度高达每秒好几百兆，这意味需要好几秒才能换入或换出一个程序。</code></pre><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><pre><code class="hljs">虚拟内存的基本思想是：每个程序都拥有自己的地址空间，这个空间被分割成多个部分多个块，每一块称作一页或页面。每一页有连续的地址范围。这些页都被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</code></pre><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><pre><code class="hljs">程序所引用的地址可以由索引，基底寄存器，段寄存器或其他方式产生，有程序产生的这些地址称为**虚拟地址**，它们共同构成一个虚拟地址空间。在没有虚拟内存的计算机上，系统直接把虚拟地址送到内存总线上，读写操作使用具有同样地址的物理内存字。而在有虚拟内存的情况下，虚拟地址不是被直接送到内存总线，而是被送到内存管理单元（MMU），mmu把虚拟地址转换为真实物理地址。虚拟地址空间按照固定大小划分成称为页面的若干单元。在物理内存中对应的单元称为页框</code></pre><p><img src="https://hcqpic.oss-cn-shanghai.aliyuncs.com/u%3D1953053099%2C3134654399%26fm%3D253%26fmt%3Dauto%26app%3D120%26f%3DPNG.webp"></p><h4 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h4><pre><code class="hljs">操作系统找到一个很少使用的页框且把它的内容写入磁盘（如果它不在磁盘上）。随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令。</code></pre><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><pre><code class="hljs">作为一种最简单的表现，虚拟地址到物理地址的映射可以概括如下：虚拟地址被分成虚拟页号（高位部分）和偏移量（地位部分）虚拟页号可以用作页表的索引，以找到该虚拟页面对应的页表项。由页表项可以找到页框号，然后把页框号拼接到偏移量的高位端，以替换虚拟页号，形成送往内存的物理地址</code></pre><p> <img src="https://hcqpic.oss-cn-shanghai.aliyuncs.com/9213b07eca8065380382c7f494dda144ac3482e8.png"></p><h4 id="页表项的结构"><a href="#页表项的结构" class="headerlink" title="页表项的结构"></a>页表项的结构</h4><ul><li>保护位 指出一个页允许什么类型的访问，只读只写还是可执行</li><li>修改和访问位 记录是否别修改过，为脏页，需要写入磁盘</li><li>页框号 借此找到物理内存</li><li>在与不在位  借此判断是否发起缺页中断</li></ul><h3 id="加速分页过程"><a href="#加速分页过程" class="headerlink" title="加速分页过程"></a>加速分页过程</h3><p>   一般分页系统面临两个问题</p><ul><li>虚拟地址到物理地址的映射必须非常快  执行一条指令会访问多次页表，如果执行一条指令需要1ns，那么页表查询必须在0.2ns之内完成</li><li>虚拟空间很大，页表也会很大 假设每页4k，32位的地址空间将有100万页，64位则更多</li></ul><h4 id="转换检测缓冲区"><a href="#转换检测缓冲区" class="headerlink" title="转换检测缓冲区"></a>转换检测缓冲区</h4><pre><code class="hljs">基于页表的物理地址转换机制，需要至少访问两次内存，对效率有很大的损耗。基于局部性原理，在计算机中设置一个小型的硬件设备，用于直接将虚拟地址映射成物理地址，这种设备称为转换检测缓冲区(TLB),它通常在mmu中，包含少量的表项，当mmu中查不到，才进行页表查询。</code></pre><h3 id="针对大内存的页表"><a href="#针对大内存的页表" class="headerlink" title="针对大内存的页表"></a>针对大内存的页表</h3><pre><code class="hljs">TLB能加快虚拟地址到物理地址的转换，但另一个问题是如何处理巨大的虚拟地址空间。考虑一个例子，虚拟地址空间为64位，页面大小为4KB，页表项大小为4Bytes，物理内存大小为512MB（参考【1】），如果采用单层页表计算可以得到页表项的数量为，页表项占用的内存大小为Byte。显然上述情况下单层页表的实现方式是不现实的</code></pre><ul><li>多级页表<br>  多级页表的引入能避免全部页表一直保存在内存中<br>  <img src="https://hcqpic.oss-cn-shanghai.aliyuncs.com/20180111231317615.png"></li><li>倒排页表<br>  在这种设计中，在实际内存中每一个页框有一个表项，而不是每一个虚拟页面有一个表项</li></ul><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><pre><code class="hljs">当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，以便为即将调入内存的页面腾出空间；如果将要被置换的页面修改过，需要回写磁盘没有被修改过，则直接覆盖</code></pre><h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><pre><code class="hljs">在缺页中断发生时，有些页面在内存中，有的页面很快就被访问，有的页面可能10，100，1000条指令之后才会访问，于是优先置换最晚访问的；但此算法不可能实现，操作系统无法预知各个页面下一次访问的时间</code></pre><h3 id="最近未使用页面置换算法"><a href="#最近未使用页面置换算法" class="headerlink" title="最近未使用页面置换算法"></a>最近未使用页面置换算法</h3><h3 id="先进先出页面置换算法"><a href="#先进先出页面置换算法" class="headerlink" title="先进先出页面置换算法"></a>先进先出页面置换算法</h3><h3 id="第二次机会页面置换算法"><a href="#第二次机会页面置换算法" class="headerlink" title="第二次机会页面置换算法"></a>第二次机会页面置换算法</h3><pre><code class="hljs">FIFO算法可能把经常使用的页面置换出去，对其修改下，检查最老页面的R位，如果它又老又没被使用，则立刻替换它</code></pre><h3 id="时间页面置换算法"><a href="#时间页面置换算法" class="headerlink" title="时间页面置换算法"></a>时间页面置换算法</h3><pre><code class="hljs">将所有的页面构造成环形链表，表针指向最老页面。缺页中断时，判断最老页面的R位，是0则淘汰，否则时针下移。</code></pre><h3 id="最近最少使用算法"><a href="#最近最少使用算法" class="headerlink" title="最近最少使用算法"></a>最近最少使用算法</h3><pre><code class="hljs">置换出未使用时间最长的页面；使用一个64位的硬件计数器，每次执行完一条指令后加一，在每次访问内存后，将当前的计数值保存在页表项。当缺页中断发生时，找到值最小的一个页面，淘汰它。</code></pre><h3 id="工作集页面置换算法"><a href="#工作集页面置换算法" class="headerlink" title="工作集页面置换算法"></a>工作集页面置换算法</h3><pre><code class="hljs">单纯的分页系统中，刚启动进程时，在内存中并没有页面。在CPU试图取第一条指令时就会产生一次缺页中断，使操作系统装入含有第一条指令的页面，按需加载，这种策略叫做请求调页。一个进程当前正在使用的页面的集合称为它的工作集。不少分页系统都会设法跟踪进程的工作集，以确保在进程运行以前，，它的工作集就已经在内存中了，这种方法称为工作集模型，其目的在于大大减少缺页中断率。在进程运行前预先装入其工作集页面也叫预先调页。</code></pre><h3 id="工作集时钟页面置换算法"><a href="#工作集时钟页面置换算法" class="headerlink" title="工作集时钟页面置换算法"></a>工作集时钟页面置换算法</h3><pre><code class="hljs">与时钟算法一样，每次缺页中断时，首先检查指针指向的页面，如果R位被置为1，该页面在当前时钟滴答中就被使用过，那么该页面就不适合被淘汰。然后把该页面的R位置为0，指针指向下一个页面。</code></pre><p><img src="https://hcqpic.oss-cn-shanghai.aliyuncs.com/125432206%20%281%29.jpg"></p><h3 id="页面置换算法小结"><a href="#页面置换算法小结" class="headerlink" title="页面置换算法小结"></a>页面置换算法小结</h3><table><thead><tr><th align="left">算法</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">最优算法</td><td align="left">不可实现，但可用作基准</td></tr><tr><td align="left">NRU（最近未使用算法）</td><td align="left">LRU的很粗糙的近似</td></tr><tr><td align="left">FIFO算法</td><td align="left">可能抛弃重要的页面</td></tr><tr><td align="left">第二次机会算法</td><td align="left">比FIFO有较大的改善</td></tr><tr><td align="left">时钟算法</td><td align="left">现实的</td></tr><tr><td align="left">LRU（最近最少使用）算法</td><td align="left">很优秀，但很难实现</td></tr><tr><td align="left">NFO（最不经常使用）算法</td><td align="left">LRU的相对粗略的近似</td></tr><tr><td align="left">老化算法</td><td align="left">非常近似lru的有效算法</td></tr><tr><td align="left">工作集算法</td><td align="left">实现起来开销很大</td></tr><tr><td align="left">工作集时钟算法</td><td align="left">好的有效算法</td></tr></tbody></table><h2 id="分页系统中的设计问题"><a href="#分页系统中的设计问题" class="headerlink" title="分页系统中的设计问题"></a>分页系统中的设计问题</h2><h3 id="局部分配策略和全局分配策略"><a href="#局部分配策略和全局分配策略" class="headerlink" title="局部分配策略和全局分配策略"></a>局部分配策略和全局分配策略</h3><pre><code class="hljs">发生缺页中断时需要选择合适的页面置换算法，另一个问题是如何在相互竞争的可运行进程间分配内存</code></pre><ul><li><p>局部分配策略</p><p>即每次内存分配在进程从属的工作集中进行页面置换，但会导致过于颠簸</p></li><li><p>全局分配策略</p><p>即在内存中全局搜索进行页面置换，但需要不断动态确认每个进程分配多少页框</p><p><strong>PFF</strong>（缺页中断率）算法，它指出了何时减少或增加进程的页面，但却完全没有说明在缺页中断时应该替换哪一个页面</p></li></ul><h3 id="负载控制"><a href="#负载控制" class="headerlink" title="负载控制"></a>负载控制</h3><p>   即使使用最优页面置换算法并对进程采用理想的全局页框分配，系统还是可能发生颠簸。事实上，一旦所有进程的组合工作集超出内存容量，就可能发生颠簸<br>   在这种情况下，没有办法能够在不影响其他进程的情况下满足那些需要更多内存的进程的需要。唯一现实的解决办法就是暂时从内存中去掉一些进程<br>   减少进程竞争内存的方法是暂时交换出部分进程到磁盘。另一方面，也要考虑多道程序设计的道数，当内存中的进程过低时，CPU空转。</p><h3 id="页面大小"><a href="#页面大小" class="headerlink" title="页面大小"></a>页面大小</h3><pre><code class="hljs">在现实情况中，随便选择一个正文段，数据段往往很可能没有填充满整个页面，这个称为内部碎片，为了减少内部碎片对空间的浪费，小页面更佳另一方面，小页面意味着更大的页表，内存与磁盘之间的传输一般是一次一页，传输过程中大部分时间都花在寻道和旋转延迟上所以传输小页面和大页面的所用时间基本是相同的，同样内存需求大小，小页面意味着需要更多传输时间此外小页面能充分的利用TLB空间</code></pre><h3 id="分离的指令空间和数据空间"><a href="#分离的指令空间和数据空间" class="headerlink" title="分离的指令空间和数据空间"></a>分离的指令空间和数据空间</h3><pre><code class="hljs">地址空间足够大时，一切都好；然而往往是地址空间不够用，这时候需要做程序与数据空间的隔离</code></pre><h3 id="共享页面"><a href="#共享页面" class="headerlink" title="共享页面"></a>共享页面</h3><pre><code class="hljs">在多道程序设计系统中，几个不同的用户同时运行同一个程序是很常见的事；显然为了避免在内存中一个页面多个副本，共享页面效率更高。这里存在一个问题，即不是所有的页面都适合共享，那些只读的（例如程序文本）可以共享，而那些数据页面则不能共享</code></pre><p><img src="https://hcqpic.oss-cn-shanghai.aliyuncs.com/wKioL1l6vk7DZI_TAAAynwGcvmQ133.jpg"></p><h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><pre><code class="hljs">在现代操作系统中，有很多大型库被众多进程使用；例如处理浏览文件以便打开文件的对话框的库，和多个图形库。把所有的这些库静态地与磁盘上的每一个可执行程序绑定在一起，将会使它们变得更佳庞大。一个更加通用的技术是使用共享库（在windows中称作dll或动态链接库）任何在目标文件中被调用了但是没有被定义的函数，都被称为未定义内部函数。链接器会在库中寻址这些未定义的外部函数。如果找到了，则将他们加载到可执行二进制文件中</code></pre><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><pre><code class="hljs">共享库实际上是一种更为同样的机制——内存映射文件 的一个特例。这种机制的思想是：进程可以通过发起一个系统调用，将一个文件映射到其虚拟地址空间的一部分在多数系统实现中，在映射共享的页面时不会实际的读入页面的内容，而是在访问页面时才会被每次一页的读入</code></pre><h3 id="清除策略"><a href="#清除策略" class="headerlink" title="清除策略"></a>清除策略</h3><pre><code class="hljs">如果发生缺页中断时系统中有大量的空闲页框，此时分页系统工作在最佳状态。如果每个页框都被占用，而且被修改过的话，再换入一个新的页面时，旧页面应首先被写回磁盘。为保证有足够的空闲页框，很多分页系统有一个称为分页守护进程的后台进程，定时被唤醒来检查内存的状况</code></pre><h3 id="虚拟内存接口"><a href="#虚拟内存接口" class="headerlink" title="虚拟内存接口"></a>虚拟内存接口</h3><pre><code class="hljs">通过让一个进程把一片内存区域的名称通知给另一个进程，而使得另一个进程可以把这piano区域映射到它的虚拟地址空间中去</code></pre><h2 id="有关实现的问题"><a href="#有关实现的问题" class="headerlink" title="有关实现的问题"></a>有关实现的问题</h2><h3 id="与分页有关的工作"><a href="#与分页有关的工作" class="headerlink" title="与分页有关的工作"></a>与分页有关的工作</h3><ul><li>进程创建时<ul><li>确定程序和数据初始值，并创建页表</li><li>在内存在为页表分配空间并初始化</li><li>在磁盘交换区分配空间，以便在一个进程换出时有放置此进程的空间</li><li>用程序正文和数据对交换区进行初始化</li><li>在进程表中存储页表和磁盘交换区信息</li></ul></li><li>进程执行时<ul><li>为新进程重置MMU，刷新TLB</li><li>新进程页表必须成为当前页表</li><li>装入进程的部分会全部页面，以减少缺页中断</li></ul></li><li>缺页中断时<ul><li>通过读寄存器来确定是哪个虚拟地址造成缺页中断</li><li>在磁盘上找到定位对应页面</li><li>找到合适页框存放新页面，必要时置换老的页面</li><li>回退程序计数器，使程序计数器指向引发缺页中断的指令，重新执行指令</li></ul></li><li>进程终止时<ul><li>释放进程的页表，页面和页面在硬盘上所占的空间。如果某些页面是和其他进程共享，则需要等到最后一个共享它的进程终止，才可以释放</li></ul></li></ul><h3 id="缺页中断的处理"><a href="#缺页中断的处理" class="headerlink" title="缺页中断的处理"></a>缺页中断的处理</h3><ul><li>硬件陷入内核，在堆栈中保存程序计数器</li><li>启动一个汇编代码例程保存通用寄存器和其他易失信息，以免被操作系统破坏、这个例程将操作系统作为一个函数调用</li><li>当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面</li><li>一旦获取到发生缺页中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致</li><li>如果选择的页框脏了，安排该页写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输解释。无论如何，该页框标记为忙，以免被其他进程占用</li><li>一旦页干净后，操作系统查找所需页面在磁盘上的地址</li><li>通过磁盘将其载入。该页面正在载入时，产生缺页中断的进程仍然被挂起，并且如果有其他进程，则选择一个用户进程运行</li><li>当磁盘中断发生时，表明该页已经被装入，页表可能已经更新可以反映它的位置，页框也被标记为正常状态</li><li>恢复发生缺页中断指令一起的状态，程序计数器重新指向该指令</li><li>调度引发缺页中断的进程，操作系统返回调用它的例程</li><li>该例程恢复寄存器和其他状态信息，返回到用户空间继续执行，就好像缺页中断没有发生一样</li></ul><h3 id="指令备份"><a href="#指令备份" class="headerlink" title="指令备份"></a>指令备份</h3><pre><code class="hljs">当程序访问不在内存中页面时，引起缺页中断的指令会半途停止并引发操作系统的陷阱，在操作系统取出所需的页面后，它需要重启引起陷阱的指令。但这并不是一件容易实现的事。通过隐藏的内部寄存器，在执行每条指令之前，把程序计数器的内存复制到该寄存器</code></pre><h3 id="锁定内存中的页面"><a href="#锁定内存中的页面" class="headerlink" title="锁定内存中的页面"></a>锁定内存中的页面</h3><pre><code class="hljs">如果某个进程在等待IO时被挂起,而另一个进程被运行执行，而这个进程产生一个缺页中断。如果分页算法是全局算法，包含IO缓冲区的页面有很小的机会被选中换出内存一种方式是锁住正在IO操作的内存中的页面以确保不被换出内存另一种方式是在内核缓冲区完成所有的IO操作，然后再将其复制到用户页面。</code></pre><h3 id="后备存储"><a href="#后备存储" class="headerlink" title="后备存储"></a>后备存储</h3><pre><code class="hljs">页面置换算法描述了如何换出内存中的页面，却没有讨论页面换出后放置在哪。</code></pre><h3 id="策略和机制的分离"><a href="#策略和机制的分离" class="headerlink" title="策略和机制的分离"></a>策略和机制的分离</h3><pre><code class="hljs">在控制系统复杂度的一种重要方法就是把策略从机制中分离出来。</code></pre><p><img src="https://hcqpic.oss-cn-shanghai.aliyuncs.com/252137255185626.jpg"></p><p>其中存储管理系统被分为三部分：</p><ul><li>一个底层MMU处理程序</li><li>一个作为内核一部分的缺页中断程序</li><li>一个运行在用户空间的外部页面调度程序</li></ul><p>优点：</p><ul><li>减轻系统复杂度</li><li>更多的模块化代码和适应性（类似于微服务）</li></ul><p>缺点：</p><ul><li>多次交叉边界 ，带来额外开销</li><li>模块间消息传递所造成的额外开销</li></ul><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>虚拟内存时一维的，虚拟地址是从0到最大地址，一个地址接着一个地址；对于许多问题来说，有两个或多个独立的地址空间可能比只有一个要好得多。<br>比如一个编译器在编译过程中会建立好多表，其中可能包括：</p><ul><li>被保存起来供打印清单用的源程序正文（用于批处理系统）</li><li>符号表，包含变量的名字和属性</li><li>包含用到的所有整型量和浮点常量的表</li><li>语法分析树，包含程序语法分析的结果</li><li>编译器内部过程调用使用的堆栈</li></ul><p>前面4张表会随着编译的进行不断增大，而堆栈的数据也会变化，现在的问题就是，每一张表的大小都不确定，那么如何指定每一张表在虚拟内存空间的地址呢？</p><p><img src="https://hcqpic.oss-cn-shanghai.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220112234601.png"></p><p>如上图，没一张表都有自己的起始地址，但是当变量很多的时候，符号表需要的空间可能会超过程序正文的起始地址，<br>这个时候就会把源程序的表的地址覆盖掉。当然编译器没有这么傻，它可以提示无法继续编译，当然这样并不合适，另一个办法就是拿出一部分没有使用的空间给符号表。造成这个问题的原因就是分页系统中的虚拟地址是一维的，所以在编译过程中必须给变量，代码分配虚拟地址。这个有点类似没有采用分页之前，进程之间使用物理地址导致相互覆盖的问题。</p><p><img src="https://hcqpic.oss-cn-shanghai.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220112234959.png"><br>所以我们可以为不同的表分配自己的空间地址，也就是分段，这样他们地址都是相对地址，全部编译完成后确定了每张表的大小，就可以计算出实际的虚拟地址了。</p><h3 id="分段的作用"><a href="#分段的作用" class="headerlink" title="分段的作用"></a>分段的作用</h3><ul><li><strong>解决编译问题</strong>： 前面提到过在编译时地址覆盖的问题，可以通过分段来解决，从而简化编译程序</li><li><strong>重新编译</strong>： 因为不同类型的数据在不同的段中，但其中一个段进行修改后，就不需要所有的段都重新进行编译。</li><li><strong>内存共享</strong>： 对内存分段，可以很容易把其中的代码段或数据段共享给其他程序，分页中因为数据代码混合在一个页面中，所以不便于共享。</li><li><strong>安全性</strong>： 将内存分为不同的段之后，因为不同段的内容类型不同，所以他们能进行的操作也不同，比如代码段的内容被加载后就不应该允许写的操作，因为这样会改变程序的行为。而在分页系统中，因为一个页不是一个逻辑实体，代码和数据可能混合在一起，无法进行安全上的控制</li><li><strong>动态链接</strong>： 动态链接是指在作业运行之前，并不把几个目标程序段链接起来。要运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，才将该段(目标程序)调入内存并进行链接。可见，动态链接也要求以段作为管理的单位</li><li><strong>保持兼容性</strong></li></ul><h3 id="纯分段的实现"><a href="#纯分段的实现" class="headerlink" title="纯分段的实现"></a>纯分段的实现</h3><pre><code class="hljs">分段和分页的实现本质是不同的。页面时定长而段不是</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
